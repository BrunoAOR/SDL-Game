
Stuff to do:

* Reorder the Engine folder to contain adecuate sub-folders:

* Create a template class to base the ComponentManager on: Something like ElementsManager<T>

* Convert the Texture class into a Component based on an abstract Renderable (or similarly named class) with the following child options
	- Sprite: 
		Simple class for a single image per texture
		Exactly what is currently available
	- SpriteSheet:
		Class that takes one texture and allows for many sub-images to be defined by using Rect (new class similar to SDL_Rect) elements to define the sub-sprites.
		This class has a currentSprite pointer that indicates the appropiate clipRect to use when rendering
		The class should expose a method to goToNextClip or maybe to go to a specific clip
		Perhaps it would be important to define a way to store diferent "sets" of clips since a single Texture (SpriteSheet) could hold animation frames to many animations
			Walking, running, jumping could all be in a single SpriteSheet. Perhaps an std::map could serve the purpose as: std::map<string, std::set<Rect>>.
			In this way, one could have not only the currentSprite pointer but also a currentAnimation pointer.

* Consider creating a Wrapper template class to container std::weak_ptr<Component> for specific components
	- Purpose: Have the addComponent and getComponent (as well as the transform member field in GameObject) return this wrapper
	- Wrapper should have an implicit bool operator overload that returns !weak_ptr.expired, so the wrapper can be evaluated in an if statement to check if its safe to use.
	- Wrapper should have overloads for the dereference operator (*) and the structure dereference operator (->) to provide direct access to the pointer being held by the weak_ptr
		(see https://stackoverflow.com/questions/21569483/c-overloading-dereference-operators)

* Review all engine classes and implement (or delete) copy constructors/assignments and move constructors/assignments

* Implement a Prefabs system. It could work through factory methods that could be written to create
	and setup a certain GameObject and then return a std::weak_ptr<GameObject> just like the usual GameOBject::createNew() function does.
		
* Implement a TextComponent to draw text on the screen. It could inherit from Texture since it will require rendering and the generation of the text terture on every change.

